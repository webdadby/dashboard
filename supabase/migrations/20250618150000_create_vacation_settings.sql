-- Drop the table if it exists to avoid conflicts
DROP TABLE IF EXISTS public.vacation_settings;

-- Create vacation_settings table with only the columns we need
CREATE TABLE public.vacation_settings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  calculation_period_months integer DEFAULT 12 NOT NULL,
  days_entitled integer DEFAULT 24 NOT NULL,
  days_per_year integer DEFAULT 24 NOT NULL,
  min_days_per_request integer DEFAULT 1,
  max_consecutive_days integer DEFAULT 60
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.vacation_settings ENABLE ROW LEVEL SECURITY;

-- Create default settings
INSERT INTO public.vacation_settings (
  calculation_period_months,
  days_entitled,
  days_per_year,
  min_days_per_request,
  max_consecutive_days
) VALUES (
  12,   -- calculation_period_months
  24,    -- days_entitled
  24,    -- days_per_year
  1,     -- min_days_per_request
  60     -- max_consecutive_days
)
ON CONFLICT (id) DO NOTHING;

-- Create or update the function that handles updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for updated_at
DROP TRIGGER IF EXISTS set_updated_at ON public.vacation_settings;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON public.vacation_settings
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Set up RLS policies if needed
-- Example: Allow all users to read settings, but only admins to modify
-- CREATE POLICY "Enable read access for all users" ON public.vacation_settings
--   FOR SELECT USING (true);

-- CREATE POLICY "Enable update for admins" ON public.vacation_settings
--   FOR UPDATE USING (auth.role() = 'authenticated');
